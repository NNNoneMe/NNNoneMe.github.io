<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="2.访问修饰符：public、private、protected、默认不写的区别public修饰，所有包都可访问到（当前类、同包、子类、其他包） Protected 其他包不能访问 Default 当前类和同包（不写修饰符的情况下） Private 只有当前类可以访问 3.java中的数据类型（八大数据类型）符类型：char    16位 存储Unicode码，用单引号赋值 尔类型：boolean">
<meta property="og:type" content="article">
<meta property="og:title" content="我的第一篇文章">
<meta property="og:url" content="http://yoursite.com/2018/06/20/我的第一篇文章/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="2.访问修饰符：public、private、protected、默认不写的区别public修饰，所有包都可访问到（当前类、同包、子类、其他包） Protected 其他包不能访问 Default 当前类和同包（不写修饰符的情况下） Private 只有当前类可以访问 3.java中的数据类型（八大数据类型）符类型：char    16位 存储Unicode码，用单引号赋值 尔类型：boolean">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/249993/201612/249993-20161212142542042-2117679195.jpg">
<meta property="og:updated_time" content="2018-06-20T11:54:18.728Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的第一篇文章">
<meta name="twitter:description" content="2.访问修饰符：public、private、protected、默认不写的区别public修饰，所有包都可访问到（当前类、同包、子类、其他包） Protected 其他包不能访问 Default 当前类和同包（不写修饰符的情况下） Private 只有当前类可以访问 3.java中的数据类型（八大数据类型）符类型：char    16位 存储Unicode码，用单引号赋值 尔类型：boolean">
<meta name="twitter:image" content="https://images2015.cnblogs.com/blog/249993/201612/249993-20161212142542042-2117679195.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/20/我的第一篇文章/"/>





  <title>我的第一篇文章 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/20/我的第一篇文章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">我的第一篇文章</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-20T19:31:45+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="2-访问修饰符：public、private、protected、默认不写的区别"><a href="#2-访问修饰符：public、private、protected、默认不写的区别" class="headerlink" title="2.访问修饰符：public、private、protected、默认不写的区别"></a>2.访问修饰符：public、private、protected、默认不写的区别</h3><p>public修饰，所有包都可访问到（当前类、同包、子类、其他包）</p>
<p>Protected 其他包不能访问</p>
<p>Default 当前类和同包（不写修饰符的情况下）</p>
<p>Private 只有当前类可以访问</p>
<h3 id="3-java中的数据类型（八大数据类型）"><a href="#3-java中的数据类型（八大数据类型）" class="headerlink" title="3.java中的数据类型（八大数据类型）"></a>3.java中的数据类型（八大数据类型）</h3><p>符类型：char    16位 存储Unicode码，用单引号赋值</p>
<p>尔类型：boolean    只有true和false两个取值</p>
<p>数值类型：</p>
<p>整数类型：四种</p>
<p>byte：8位    最大存储数据量位255，存放范围是-128~127</p>
<p>short：16位 最大存储数据量位65536 范围-32768~32767</p>
<p>int：32位 最大存储数据量为232-1 范围-231 ~231-1</p>
<p>long： 64位</p>
<p>浮点数类型：2种</p>
<p>float：32位，数据范围3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F</p>
<p>double:64位</p>
<h3 id="4-数据类型之间的转换"><a href="#4-数据类型之间的转换" class="headerlink" title="4.数据类型之间的转换"></a>4.数据类型之间的转换</h3><p>简单类型数据转换的两种方式：自动转换、强制转换。</p>
<p>自动转换：小—&gt;大        强制转换：大—&gt;小（会导致溢出或精度下降）</p>
<h3 id="5-栈（stack）、堆（heap）、方法区（method-area）"><a href="#5-栈（stack）、堆（heap）、方法区（method-area）" class="headerlink" title="5.栈（stack）、堆（heap）、方法区（method area）"></a>5.栈（stack）、堆（heap）、方法区（method area）</h3><p>定义一个数据类型的变量，一个对象的引用，函数调用的现场保存都是在JVM的栈空间；通过new关键字和构造器创建的对象放在堆空间，堆是垃圾收集器管理的主要区域。方法区和堆都是各个现场共享的内存区域，用于存储已经被JVM加载器的类信息、常量、静态变量等数据。栈空间操作起来最快但是很小，通常大量对象都是存放在堆空间。</p>
<h3 id="6-数组中有没有length-方法？String有没有length-方法？"><a href="#6-数组中有没有length-方法？String有没有length-方法？" class="headerlink" title="6.数组中有没有length()方法？String有没有length()方法？"></a>6.数组中有没有length()方法？String有没有length()方法？</h3><p>数组中没有length()方法，有length属性。String有length()方法。JavaScript中获得字符串长度是通过length属性得到的。</p>
<h3 id="7-x-equals-y-true-hashcodeUR不同，是否正确？"><a href="#7-x-equals-y-true-hashcodeUR不同，是否正确？" class="headerlink" title="7.x.equals(y)==true,hashcodeUR不同，是否正确？"></a>7.x.equals(y)==true,hashcodeUR不同，是否正确？</h3><p>不对，应该相同。Java中对equals方法和hashCode方法的规定：（1）如果两个对象相同（equals方法返回TRUE），那么它们的hashCode值一定相同；（2）如果两个对象的hashCode相同，它们不一定相同。</p>
<h3 id="8-是否可以继承String类？"><a href="#8-是否可以继承String类？" class="headerlink" title="8.是否可以继承String类？"></a>8.是否可以继承String类？</h3><p>String类是final类，不可以被继承</p>
<h3 id="9-String和StringBuilder、StringBuffer的区别"><a href="#9-String和StringBuilder、StringBuffer的区别" class="headerlink" title="9.String和StringBuilder、StringBuffer的区别"></a>9.String和StringBuilder、StringBuffer的区别</h3><p>Java平台提供了两种字符串类型：String和StringBuilder/StringBuffer，它们可以存储和操作字符串。其中String是只读字符串，也就是说String引用的字符串内容是不能改变的。而StringBuffer类表示的字符串对象可以直接进行修改。</p>
<h3 id="10-重写（override）和重载（overload）的区别"><a href="#10-重写（override）和重载（overload）的区别" class="headerlink" title="10.重写（override）和重载（overload）的区别"></a>10.重写（override）和重载（overload）的区别</h3><p>方法的重载和重写都是实现多态的方式，区别是重载实现的是编译时的多态，重写是实现运行时的多态性。重载发生在一个类中。同名方法如果有不同的参数列表则视为重载。（方法的重载）；重写发生在子类与父类之间，重写要求子类被重写的方法与父类被重写的方法有相同的返回类型。而重载对返回类型没有特殊要求。</p>
<h3 id="11-类初始化顺序"><a href="#11-类初始化顺序" class="headerlink" title="11.类初始化顺序"></a>11.类初始化顺序</h3><p>（静态变量、静态初始化块）–&gt;（变量、初始化块）–&gt; 构造器；如果有父类，则顺序是：父类static方法 –&gt; 子类static方法 –&gt; 父类构造方法- -&gt; 子类构造方法</p>
<h3 id="12-抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#12-抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="12.抽象类（abstract class）和接口（interface）有什么异同？"></a>12.抽象类（abstract class）和接口（interface）有什么异同？</h3><p>抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的应用。接口比抽象类更加抽象，抽象类中，可以定义构造器、抽象方法和具体方法，而接口中不能定义构造器，其中的方法全部是抽象方法。抽象类中的成员可以用private、默认、protected、public来修饰，而接口中的成员必须是public。抽象类中可以定义成员变量，接口定义的成员变量实际是都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必有抽象方法。</p>
<h3 id="13-静态变量和实例变量的区别"><a href="#13-静态变量和实例变量的区别" class="headerlink" title="13.静态变量和实例变量的区别"></a>13.静态变量和实例变量的区别</h3><p>静态变量是被static修饰的变量，也称为类变量，属于类不属于类的任何一个变量，一个类无论创建了多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例。需要先创建实例对象通过对象才能访问到。静态便利可以实现让多个对象共享内存。</p>
<h3 id="14-是否可以从一个静态方法内部发出对非静态方法的调用？"><a href="#14-是否可以从一个静态方法内部发出对非静态方法的调用？" class="headerlink" title="14.是否可以从一个静态方法内部发出对非静态方法的调用？"></a>14.是否可以从一个静态方法内部发出对非静态方法的调用？</h3><p>不能，静态方法只能访问今天成员，因为非静态方法的调用要先创建对象。</p>
<h3 id="15-一个“-java”的源文件中是否可以包含多个类（非内部类）？"><a href="#15-一个“-java”的源文件中是否可以包含多个类（非内部类）？" class="headerlink" title="15.一个“.java”的源文件中是否可以包含多个类（非内部类）？"></a>15.一个“.java”的源文件中是否可以包含多个类（非内部类）？</h3><p>可以，但同一源文件中最多只能有一个公开类，而文件名必须与公开类名保持完全一致。</p>
<h3 id="16-java中的final关键字有哪些用法？"><a href="#16-java中的final关键字有哪些用法？" class="headerlink" title="16.java中的final关键字有哪些用法？"></a>16.java中的final关键字有哪些用法？</h3><p>（1）修饰类：表示该类不能被继承；（2）修饰方法：表示该方法不能被重写；（3）修饰变量：表示该变量只能一次</p>
<h3 id="17-try-里面有一个return语句，那么紧跟在这个try后的finally-里的代码是否会执行，什么时候执行？"><a href="#17-try-里面有一个return语句，那么紧跟在这个try后的finally-里的代码是否会执行，什么时候执行？" class="headerlink" title="17.try{}里面有一个return语句，那么紧跟在这个try后的finally{}里的代码是否会执行，什么时候执行？"></a>17.try{}里面有一个return语句，那么紧跟在这个try后的finally{}里的代码是否会执行，什么时候执行？</h3><p>会执行，在方法返回调用之前执行。</p>
<h3 id="18-列出常见的运行时异常"><a href="#18-列出常见的运行时异常" class="headerlink" title="18.列出常见的运行时异常"></a>18.列出常见的运行时异常</h3><p>算术异常、类转换异常、非法参数异常、下标越界异常、空指针异常、安全异常</p>
<h3 id="19-List、Set、Map是否继承自Collection接口？"><a href="#19-List、Set、Map是否继承自Collection接口？" class="headerlink" title="19.List、Set、Map是否继承自Collection接口？"></a>19.List、Set、Map是否继承自Collection接口？</h3><p>List、Set是，Map不是。Map是键值对映射容器，与List和Set有明显的区别，Set存储的零散元素而不允许有重复的元素，List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h3 id="20-List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#20-List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="20.List、Map、Set三个接口存取元素时，各有什么特点？"></a>20.List、Map、Set三个接口存取元素时，各有什么特点？</h3><p>List以特定的索引来存取元素，允许重复元素。</p>
<p>Set不能存放重复元素。</p>
<p>Map保存键值对映射，映射关系可以是一对一、或多对一</p>
<h3 id="21-编写多线程程序有几种实现方式？"><a href="#21-编写多线程程序有几种实现方式？" class="headerlink" title="21.编写多线程程序有几种实现方式？"></a>21.编写多线程程序有几种实现方式？</h3><p>继承Thread类；实现Runnable接口；两种方式都要重写run（）方法来定义线程行为，推荐使用后者，更加灵活（继承是单继承）</p>
<h3 id="22-java中有几种类型的流？"><a href="#22-java中有几种类型的流？" class="headerlink" title="22.java中有几种类型的流？"></a>22.java中有几种类型的流？</h3><p>字节流和字符流。字节流继承与InputStream、OutputStream，字符流继承与Reader、Writer。</p>
<h3 id="23-XML文档定义有几种形式？他们本质之间的区别？解析XML文档有哪几种方式？"><a href="#23-XML文档定义有几种形式？他们本质之间的区别？解析XML文档有哪几种方式？" class="headerlink" title="23.XML文档定义有几种形式？他们本质之间的区别？解析XML文档有哪几种方式？"></a>23.XML文档定义有几种形式？他们本质之间的区别？解析XML文档有哪几种方式？</h3><p> XML文档定义为DTD和Schema两种形式，两者都是对XML语法的约束；本质在于Schema本身也是一个XML文件，可以被XML解析器解析，约束能力较DTD大。对XML的解析主要有DOM解析（文档对象模型）、SAX解析和StAX解析。DOM解析必须在解析文件之前把整个文档装入内存，而SAX解析是时间驱动型的XML解析方式。</p>
<h3 id="24-项目中那些地方用到了XML技术？"><a href="#24-项目中那些地方用到了XML技术？" class="headerlink" title="24.项目中那些地方用到了XML技术？"></a>24.项目中那些地方用到了XML技术？</h3><p>XML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装起来，然后压缩打包加密后通过网络传送给接受者。接受解密与压缩后再从XML文件中还原相关信息进行处理，XML曾经是系统间交换数据的事实标准，但此项功能现在基本被JSON取而代之。很多软件依然使用XML来存储配置信息，我们在项目中通常也将作为配置信息的硬代码写入XML文件中，java中很多框架也是这么做的。</p>
<h3 id="25-阐述JDBC操作数据库的步骤"><a href="#25-阐述JDBC操作数据库的步骤" class="headerlink" title="25.阐述JDBC操作数据库的步骤"></a>25.阐述JDBC操作数据库的步骤</h3><p>加载驱动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br></pre></td></tr></table></figure>
<p>创建连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection con = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@localhost:1521:orcl"</span>,<span class="string">"scott"</span>,<span class="string">"tiger"</span>);</span><br></pre></td></tr></table></figure>
<p>创建语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = con.prepareStatement(<span class="string">"select * from emp where sal between ? and ?"</span>);</span><br></pre></td></tr></table></figure>
<p>执行语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = ps.executeQuery();</span><br></pre></td></tr></table></figure>
<h3 id="26-Statement和PreparedStatement有什么区别？哪一个性能更好？"><a href="#26-Statement和PreparedStatement有什么区别？哪一个性能更好？" class="headerlink" title="26.Statement和PreparedStatement有什么区别？哪一个性能更好？"></a>26.Statement和PreparedStatement有什么区别？哪一个性能更好？</h3><p>与Statement相比：PreparedStatement接口代表预编译的语句，主要优势在于减少SQL的编译错误并增加SQL的安全性；PreparedStatement中的SQL语句是可以带参数的，避免了用字符串来拼接SQL语句的麻烦和不安全；批量处理SQL或者频繁执行相同的查询是，PreparedStatement有明显的性能上的优势，数据库可以将编译优化后的SQL语句缓存下来，下次执行就会很快。</p>
<h3 id="27-在进行数据库编程时，连接池有什么作用？"><a href="#27-在进行数据库编程时，连接池有什么作用？" class="headerlink" title="27.在进行数据库编程时，连接池有什么作用？"></a>27.在进行数据库编程时，连接池有什么作用？</h3><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP三次握手，释放连接需要四次握手），提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池中获取，使用结束后归还连接池而不必要关闭连接，从而避免频繁创建和释放连接所造成的开销。基于java的开源数据库连接池主要有：c3p0、proxool、DBCP等。</p>
<h3 id="28-什么是DAO模式？"><a href="#28-什么是DAO模式？" class="headerlink" title="28.什么是DAO模式？"></a>28.什么是DAO模式？</h3><p>DAO（Data Access Object）是一个为数据库或其他持久化机制提供的抽象接口对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共的API中。用程序的语言来讲，就是建立一个接口，接口定义了此应用程序中将会用到的所有事务方法。</p>
<h3 id="29-事务打ACID是指什么？"><a href="#29-事务打ACID是指什么？" class="headerlink" title="29.事务打ACID是指什么？"></a>29.事务打ACID是指什么？</h3><p>原子性(Atomic):事务中各项操作，要么全做要么全不做，任何一项失败都会导致整个事务的失败；</p>
<p>一致性(Consistent):事务结束后系统状态是一致的；</p>
<p>隔离型(Isolated):并发执行的事务彼此无法看到对方的中间状态；</p>
<p>持久性(Durable):事务完成后所做的改动都会被持久化，即是发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</p>
<h3 id="30-简述正则表达式及其用途"><a href="#30-简述正则表达式及其用途" class="headerlink" title="30.简述正则表达式及其用途"></a>30.简述正则表达式及其用途</h3><p>在编写处理字符串程序时，经常会查找符合某些复杂规则的字符串的需求。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<h3 id="31-获得一个类的类对象有哪些方式？"><a href="#31-获得一个类的类对象有哪些方式？" class="headerlink" title="31.获得一个类的类对象有哪些方式？"></a>31.获得一个类的类对象有哪些方式？</h3><p>方法1：类型.class,例如：String.class</p>
<p>方法2:对象.getClass(),例如：”hello”.getClass()</p>
<p>方法3：Class.forName(),例如：Class.forName(“java.lang.String”)</p>
<h3 id="32-如何通过放射创建对象？"><a href="#32-如何通过放射创建对象？" class="headerlink" title="32.如何通过放射创建对象？"></a>32.如何通过放射创建对象？</h3><p>方法1：通过类对象调用newInstance()方法</p>
<p>方法2：通过类对象的getConstructor()或getDeclaredConstuctor()获取构造器对象并调用newInstance()方法来创建对象。</p>
<h3 id="33-简述一下你了解的设计模式。"><a href="#33-简述一下你了解的设计模式。" class="headerlink" title="33.简述一下你了解的设计模式。"></a>33.简述一下你了解的设计模式。</h3><p>所谓设计模式，就是一套被反复使用的代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码的可靠性。</p>
<p>工厂模式：工厂类可以根据条件生成不同的子类型实例，这些子类型有一个公共的抽象父类并且实现了相同的方法，但这些方法针对不同的数据进行不同的操作（多态方法）。当得到子类的实例后，我们可以调用父类中的方法而不用考虑到底返回的是哪一子类的实例。</p>
<p>代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。</p>
<p>适配器模式：把一个类的接口变成客户端所期待的另一个接口，从而使原本接口不匹配而无法在一起使用的类能够一起工作。</p>
<p>单例模式：</p>
<h3 id="34-servlet的生命周期"><a href="#34-servlet的生命周期" class="headerlink" title="34.servlet的生命周期"></a>34.servlet的生命周期</h3><p>四个重要的生命周期方法：</p>
<p>构造方法：创建servlet对象时候调用。默认情况下，第一次访问servlet时候创建servlet对象（只调用一次，servlet对象在tomcat是单实例的）</p>
<p>init方法：创建servlet对象的时候调用，只调用一次</p>
<p>service方法：每次发出请求时候调用</p>
<p>destroy方法：销毁servlet对象的时候调用。停止服务器或者重新部署应用时销毁servlet对象。只调用一次。</p>
<p>web容器加载servlet并将其实例化后，servlet生命周期开始，容器运行init()方法进行servlet初始化；请求到达时调用servlet的service()方法，service()方法会根据需要调用与请求对应的doGet()或doPost()等方法；当服务器关闭或项目被卸载时服务器将servlet实例销毁，此时会调用servlet的destroy()方法。</p>
<h3 id="35-转发（forward）和重定向（redirect）的区别？"><a href="#35-转发（forward）和重定向（redirect）的区别？" class="headerlink" title="35.转发（forward）和重定向（redirect）的区别？"></a>35.转发（forward）和重定向（redirect）的区别？</h3><p>转发是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL,把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器不知道服务器发送的内容从哪里来，所有他的地址栏中还是原来的地址。</p>
<p>重定向就是服务器根据逻辑，发送一个状态码，告诉刘拉起去重新请求那个地址，因此可以从浏览器的地址栏中可以看到跳转后的地址。重定向无法访问到服务器保护起来的资源，但是可以从一个网站重定向到另外一个网站。</p>
<p>转发更加高效，所以在满足需要时尽量使用forward（通过调用RequestDispatcher对象的forward方法），并且这样也有利于隐藏实际链接。</p>
<h3 id="36-JSP的九大内置对象的作用？"><a href="#36-JSP的九大内置对象的作用？" class="headerlink" title="36.JSP的九大内置对象的作用？"></a>36.JSP的九大内置对象的作用？</h3><p>request:封装客户端的请求，其中包含来自GET或POST请求的参数；</p>
<p>response：封装服务器对客户端的响应；</p>
<p>pageContext：通过该对象获取其他对象；</p>
<p>session:封装用户的会话对象；</p>
<p>application：封装服务器运行环境的对象；</p>
<p>out：输出服务器响应的输出流对象</p>
<p>config：web应用的配置对象；</p>
<p>page：JSP页面本身</p>
<p>exception：封装页面抛出的异常的对象；</p>
<h3 id="37-get和post请求的区别？"><a href="#37-get和post请求的区别？" class="headerlink" title="37.get和post请求的区别？"></a>37.get和post请求的区别？</h3><p>get请求是用来从服务器上获得资源，而post请求是用来向服务器提交数据；</p>
<p>get将表单中的数据按照name=value的形式，添加到action所指向的URL后面，并且两者用“?”连接，各个变量之间用&amp;连接；post是将表单中的数据放在http协议的请求头或者请求体重，传递到action所指向的URL；</p>
<p>get传输的数据要求要受到URL长度（1024字节）的限制；而post可以传输大量的数据，上传文件通常要使用post请求</p>
<p>使用get时，参数会显示在地址栏中，如果这些数据不是敏感数据，可以使用get，对于敏感数还是应该使用post</p>
<h3 id="38-JSP中的四种作用域"><a href="#38-JSP中的四种作用域" class="headerlink" title="38.JSP中的四种作用域"></a>38.JSP中的四种作用域</h3><p>page：代表一个与页面相关的对象和属性</p>
<p>request：代表与web客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个web组件；需要在页面显示的临时数据可以置于此域</p>
<p>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中</p>
<p>application：代表与整个web应用程序相关的对象和属性，他实质上是跨域整个web应用程序，包含多个页面、请求和会话的全局作用域</p>
<h3 id="39-servlet中如何获取用户提交的查询参数或表单数据？"><a href="#39-servlet中如何获取用户提交的查询参数或表单数据？" class="headerlink" title="39.servlet中如何获取用户提交的查询参数或表单数据？"></a>39.servlet中如何获取用户提交的查询参数或表单数据？</h3><p>可以通过请求对象（HtttpServlettRequest）的getParameter()方法来通过参数名获得参数值。如果有包含多个值的参数（例如复选框），可以通过请求对象的getParameterValues()方法获得。当然也可以通过请求对象的getParameterMap()获得一个参数名和参数值得映射（Map）</p>
<h3 id="40-什么是ORM？"><a href="#40-什么是ORM？" class="headerlink" title="40.什么是ORM？"></a>40.什么是ORM？</h3><p>对象关系映射，是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换为java对象，其本质就是将数据从一种形式转换到另一种形式。</p>
<h3 id="41-解释一下mybatis中命名空间（namespace）的作用"><a href="#41-解释一下mybatis中命名空间（namespace）的作用" class="headerlink" title="41.解释一下mybatis中命名空间（namespace）的作用"></a>41.解释一下mybatis中命名空间（namespace）的作用</h3><p>在项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识不是很容易。为了解决这个问题，在mybatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每一个SQL语句就成了定义在这个命名空间中唯一的一个id。只要我们保证每个命名空间中的这个id是唯一的，即使在不同的映射文件中的语句id相同，也不会产生冲突。</p>
<h3 id="42-什么是IOC和DI？DI如何实现？"><a href="#42-什么是IOC和DI？DI如何实现？" class="headerlink" title="42.什么是IOC和DI？DI如何实现？"></a>42.什么是IOC和DI？DI如何实现？</h3><p>IOC叫做控制反转，DI叫做依赖注入，是对IOC更加简单的诠释。控制反转就是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”就是对最贱对象控制权的转移，从程序代码的本身转移到外部容器，由容器来创建对象并管理对象之间的依赖关系。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖协作的对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成，DI是对IOC更加准确的描述。</p>
<h3 id="43-spring容器的理解"><a href="#43-spring容器的理解" class="headerlink" title="43.spring容器的理解"></a>43.spring容器的理解</h3><p>它提供了依赖注入（Dependency Injection）特征来实现容器对Bean的管理 </p>
<p>容器是Spring框架实现功能的核心，容器不只是帮我们创建了对象那么简单，它负责了对象整个的生命周期的管理——创建、装配、销毁。关于Spring的这个容器你最常听闻的一个术语就是IOC容器</p>
<h3 id="44-什么叫AOP（面向切面编程）？"><a href="#44-什么叫AOP（面向切面编程）？" class="headerlink" title="44.什么叫AOP（面向切面编程）？"></a>44.什么叫AOP（面向切面编程）？</h3><p>AOP（Aspect-Oriented Programming）是指一种程序的设计范型</p>
<p>事务、日志、安全性等</p>
<h3 id="45-如何在web项目中配置spring的IOC容器？"><a href="#45-如何在web项目中配置spring的IOC容器？" class="headerlink" title="45.如何在web项目中配置spring的IOC容器？"></a>45.如何在web项目中配置spring的IOC容器？</h3><p>在web项目的配置文件中web.xml中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="46-如何在web项目中配置springMVC？"><a href="#46-如何在web项目中配置springMVC？" class="headerlink" title="46.如何在web项目中配置springMVC？"></a>46.如何在web项目中配置springMVC？</h3><p>在web项目的配置文件中web.xml中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="47-springMVC的工作原理是怎样的？"><a href="#47-springMVC的工作原理是怎样的？" class="headerlink" title="47.springMVC的工作原理是怎样的？"></a>47.springMVC的工作原理是怎样的？</h3><p><img src="https://images2015.cnblogs.com/blog/249993/201612/249993-20161212142542042-2117679195.jpg" alt="img"></p>
<p>①用户发送请求到前端控制器</p>
<p>②DispatcherServlet 收到请求调用HandlerMapping处理器映射器</p>
<p>③处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器（如有则生成）一并返回给DispatcherServlet 。</p>
<p>④DispatcherServlet 调用HandlerAdapter处理器适配器</p>
<p>⑤HandlerAdapter经过适配调用具体的处理器（Controller,也叫后端控制器）</p>
<p>⑥Controller执行完成后返回ModelAndView</p>
<p>⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet </p>
<p>⑧DispatcherServlet 将ModelAndView传给ViewReslover视图解析器</p>
<p>⑨ViewReslover解析后返回具体的View</p>
<p>⑩DispatcherServlet 根据View进行渲染视图（即将模型数据填充至视图中）</p>
<p>最后：DispatcherServlet 响应用户</p>
<h3 id="48-collection集合"><a href="#48-collection集合" class="headerlink" title="48.collection集合"></a>48.collection集合</h3><p>collection接口下：List接口、Set接口</p>
<p>List：列表。特点是1.有序（存储元素的顺序和取出元素的顺序相同）、2.该集合中的元素都有索引，可以通过索引来访问元素、3.该集合可以存储相同的元素。</p>
<p>Set：集：特点是1.不能存储重复的元素、2.存入的元素顺序和取出元素的顺序不一定相同。</p>
<p>List具体实现：ArrayList    底层是数组结构，支持长度可变的数组，查询快</p>
<p>​            LinkedList    底层是链表结构，每个元素会记住后面元素的位置，对元素的增删效率高</p>
<p>​            vector        底层是数组结构，可变长度数组</p>
<p>Set具体实现：HashSet:    底层是哈希表，不保证顺序，是不同步的</p>
<p>​                        a.不关心顺序</p>
<p>​                        b.提高了查询效率</p>
<p>​                        c.不能存储相同元素</p>
<p>​            TreeSet:        底层是二叉树结构，可以给set集合中的元素进行制定顺序的排序，默认情况下是通过自然顺序排序的</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/20/hello-world/" rel="next" title="Hello NNNoneMe">
                <i class="fa fa-chevron-left"></i> Hello NNNoneMe
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-访问修饰符：public、private、protected、默认不写的区别"><span class="nav-number">1.</span> <span class="nav-text">2.访问修饰符：public、private、protected、默认不写的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-java中的数据类型（八大数据类型）"><span class="nav-number">2.</span> <span class="nav-text">3.java中的数据类型（八大数据类型）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-数据类型之间的转换"><span class="nav-number">3.</span> <span class="nav-text">4.数据类型之间的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-栈（stack）、堆（heap）、方法区（method-area）"><span class="nav-number">4.</span> <span class="nav-text">5.栈（stack）、堆（heap）、方法区（method area）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-数组中有没有length-方法？String有没有length-方法？"><span class="nav-number">5.</span> <span class="nav-text">6.数组中有没有length()方法？String有没有length()方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-x-equals-y-true-hashcodeUR不同，是否正确？"><span class="nav-number">6.</span> <span class="nav-text">7.x.equals(y)==true,hashcodeUR不同，是否正确？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-是否可以继承String类？"><span class="nav-number">7.</span> <span class="nav-text">8.是否可以继承String类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-String和StringBuilder、StringBuffer的区别"><span class="nav-number">8.</span> <span class="nav-text">9.String和StringBuilder、StringBuffer的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-重写（override）和重载（overload）的区别"><span class="nav-number">9.</span> <span class="nav-text">10.重写（override）和重载（overload）的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-类初始化顺序"><span class="nav-number">10.</span> <span class="nav-text">11.类初始化顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-抽象类（abstract-class）和接口（interface）有什么异同？"><span class="nav-number">11.</span> <span class="nav-text">12.抽象类（abstract class）和接口（interface）有什么异同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-静态变量和实例变量的区别"><span class="nav-number">12.</span> <span class="nav-text">13.静态变量和实例变量的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-是否可以从一个静态方法内部发出对非静态方法的调用？"><span class="nav-number">13.</span> <span class="nav-text">14.是否可以从一个静态方法内部发出对非静态方法的调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-一个“-java”的源文件中是否可以包含多个类（非内部类）？"><span class="nav-number">14.</span> <span class="nav-text">15.一个“.java”的源文件中是否可以包含多个类（非内部类）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-java中的final关键字有哪些用法？"><span class="nav-number">15.</span> <span class="nav-text">16.java中的final关键字有哪些用法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-try-里面有一个return语句，那么紧跟在这个try后的finally-里的代码是否会执行，什么时候执行？"><span class="nav-number">16.</span> <span class="nav-text">17.try{}里面有一个return语句，那么紧跟在这个try后的finally{}里的代码是否会执行，什么时候执行？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-列出常见的运行时异常"><span class="nav-number">17.</span> <span class="nav-text">18.列出常见的运行时异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-List、Set、Map是否继承自Collection接口？"><span class="nav-number">18.</span> <span class="nav-text">19.List、Set、Map是否继承自Collection接口？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-List、Map、Set三个接口存取元素时，各有什么特点？"><span class="nav-number">19.</span> <span class="nav-text">20.List、Map、Set三个接口存取元素时，各有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-编写多线程程序有几种实现方式？"><span class="nav-number">20.</span> <span class="nav-text">21.编写多线程程序有几种实现方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-java中有几种类型的流？"><span class="nav-number">21.</span> <span class="nav-text">22.java中有几种类型的流？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-XML文档定义有几种形式？他们本质之间的区别？解析XML文档有哪几种方式？"><span class="nav-number">22.</span> <span class="nav-text">23.XML文档定义有几种形式？他们本质之间的区别？解析XML文档有哪几种方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-项目中那些地方用到了XML技术？"><span class="nav-number">23.</span> <span class="nav-text">24.项目中那些地方用到了XML技术？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-阐述JDBC操作数据库的步骤"><span class="nav-number">24.</span> <span class="nav-text">25.阐述JDBC操作数据库的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-Statement和PreparedStatement有什么区别？哪一个性能更好？"><span class="nav-number">25.</span> <span class="nav-text">26.Statement和PreparedStatement有什么区别？哪一个性能更好？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-在进行数据库编程时，连接池有什么作用？"><span class="nav-number">26.</span> <span class="nav-text">27.在进行数据库编程时，连接池有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-什么是DAO模式？"><span class="nav-number">27.</span> <span class="nav-text">28.什么是DAO模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-事务打ACID是指什么？"><span class="nav-number">28.</span> <span class="nav-text">29.事务打ACID是指什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-简述正则表达式及其用途"><span class="nav-number">29.</span> <span class="nav-text">30.简述正则表达式及其用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-获得一个类的类对象有哪些方式？"><span class="nav-number">30.</span> <span class="nav-text">31.获得一个类的类对象有哪些方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-如何通过放射创建对象？"><span class="nav-number">31.</span> <span class="nav-text">32.如何通过放射创建对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-简述一下你了解的设计模式。"><span class="nav-number">32.</span> <span class="nav-text">33.简述一下你了解的设计模式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-servlet的生命周期"><span class="nav-number">33.</span> <span class="nav-text">34.servlet的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-转发（forward）和重定向（redirect）的区别？"><span class="nav-number">34.</span> <span class="nav-text">35.转发（forward）和重定向（redirect）的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-JSP的九大内置对象的作用？"><span class="nav-number">35.</span> <span class="nav-text">36.JSP的九大内置对象的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-get和post请求的区别？"><span class="nav-number">36.</span> <span class="nav-text">37.get和post请求的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-JSP中的四种作用域"><span class="nav-number">37.</span> <span class="nav-text">38.JSP中的四种作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-servlet中如何获取用户提交的查询参数或表单数据？"><span class="nav-number">38.</span> <span class="nav-text">39.servlet中如何获取用户提交的查询参数或表单数据？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-什么是ORM？"><span class="nav-number">39.</span> <span class="nav-text">40.什么是ORM？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-解释一下mybatis中命名空间（namespace）的作用"><span class="nav-number">40.</span> <span class="nav-text">41.解释一下mybatis中命名空间（namespace）的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-什么是IOC和DI？DI如何实现？"><span class="nav-number">41.</span> <span class="nav-text">42.什么是IOC和DI？DI如何实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-spring容器的理解"><span class="nav-number">42.</span> <span class="nav-text">43.spring容器的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-什么叫AOP（面向切面编程）？"><span class="nav-number">43.</span> <span class="nav-text">44.什么叫AOP（面向切面编程）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-如何在web项目中配置spring的IOC容器？"><span class="nav-number">44.</span> <span class="nav-text">45.如何在web项目中配置spring的IOC容器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-如何在web项目中配置springMVC？"><span class="nav-number">45.</span> <span class="nav-text">46.如何在web项目中配置springMVC？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-springMVC的工作原理是怎样的？"><span class="nav-number">46.</span> <span class="nav-text">47.springMVC的工作原理是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-collection集合"><span class="nav-number">47.</span> <span class="nav-text">48.collection集合</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
